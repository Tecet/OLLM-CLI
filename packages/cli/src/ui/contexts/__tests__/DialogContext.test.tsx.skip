/**
 * Tests for DialogContext
 */

import { describe, it, expect, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import React from 'react';
import { DialogProvider, useDialog } from '../DialogContext.js';
import type { Hook } from '@ollm/ollm-cli-core/hooks/types.js';

describe('DialogContext', () => {
  const mockHook: Hook = {
    id: 'test-hook-1',
    name: 'test-hook',
    command: 'node',
    args: ['script.js'],
    source: 'workspace',
  };

  const mockHash = 'sha256:abc123';

  it('should provide dialog context', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <DialogProvider>{children}</DialogProvider>
    );

    const { result } = renderHook(() => useDialog(), { wrapper });

    expect(result.current).toBeDefined();
    expect(result.current.state).toEqual({
      activeDialog: null,
      isVisible: false,
    });
  });

  it('should show hook approval dialog', async () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <DialogProvider>{children}</DialogProvider>
    );

    const { result } = renderHook(() => useDialog(), { wrapper });

    let approvalPromise: Promise<boolean>;

    act(() => {
      approvalPromise = result.current.showHookApproval(mockHook, mockHash);
    });

    // Dialog should be visible
    expect(result.current.state.isVisible).toBe(true);
    expect(result.current.state.activeDialog).toBeDefined();
    expect(result.current.state.activeDialog?.type).toBe('hookApproval');

    // Approve the dialog
    act(() => {
      if (result.current.state.activeDialog?.type === 'hookApproval') {
        result.current.state.activeDialog.onApprove();
      }
    });

    // Promise should resolve to true
    const approved = await approvalPromise!;
    expect(approved).toBe(true);

    // Dialog should be closed
    expect(result.current.state.isVisible).toBe(false);
    expect(result.current.state.activeDialog).toBeNull();
  });

  it('should deny hook approval', async () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <DialogProvider>{children}</DialogProvider>
    );

    const { result } = renderHook(() => useDialog(), { wrapper });

    let approvalPromise: Promise<boolean>;

    act(() => {
      approvalPromise = result.current.showHookApproval(mockHook, mockHash);
    });

    // Deny the dialog
    act(() => {
      if (result.current.state.activeDialog?.type === 'hookApproval') {
        result.current.state.activeDialog.onDeny();
      }
    });

    // Promise should resolve to false
    const approved = await approvalPromise!;
    expect(approved).toBe(false);

    // Dialog should be closed
    expect(result.current.state.isVisible).toBe(false);
  });

  it('should show confirmation dialog', async () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <DialogProvider>{children}</DialogProvider>
    );

    const { result } = renderHook(() => useDialog(), { wrapper });

    let confirmPromise: Promise<boolean>;

    act(() => {
      confirmPromise = result.current.showConfirmation('Test', 'Are you sure?');
    });

    // Dialog should be visible
    expect(result.current.state.isVisible).toBe(true);
    expect(result.current.state.activeDialog?.type).toBe('confirmation');

    // Confirm
    act(() => {
      if (result.current.state.activeDialog?.type === 'confirmation') {
        result.current.state.activeDialog.onConfirm();
      }
    });

    const confirmed = await confirmPromise!;
    expect(confirmed).toBe(true);
  });

  it('should show error dialog', async () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <DialogProvider>{children}</DialogProvider>
    );

    const { result } = renderHook(() => useDialog(), { wrapper });

    let errorPromise: Promise<void>;

    act(() => {
      errorPromise = result.current.showError('Error', 'Something went wrong');
    });

    // Dialog should be visible
    expect(result.current.state.isVisible).toBe(true);
    expect(result.current.state.activeDialog?.type).toBe('error');

    // Close
    act(() => {
      if (result.current.state.activeDialog?.type === 'error') {
        result.current.state.activeDialog.onClose();
      }
    });

    await errorPromise!;
    expect(result.current.state.isVisible).toBe(false);
  });

  it('should show info dialog', async () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <DialogProvider>{children}</DialogProvider>
    );

    const { result } = renderHook(() => useDialog(), { wrapper });

    let infoPromise: Promise<void>;

    act(() => {
      infoPromise = result.current.showInfo('Info', 'FYI');
    });

    // Dialog should be visible
    expect(result.current.state.isVisible).toBe(true);
    expect(result.current.state.activeDialog?.type).toBe('info');

    // Close
    act(() => {
      if (result.current.state.activeDialog?.type === 'info') {
        result.current.state.activeDialog.onClose();
      }
    });

    await infoPromise!;
    expect(result.current.state.isVisible).toBe(false);
  });

  it('should close dialog manually', () => {
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <DialogProvider>{children}</DialogProvider>
    );

    const { result } = renderHook(() => useDialog(), { wrapper });

    act(() => {
      result.current.showHookApproval(mockHook, mockHash);
    });

    expect(result.current.state.isVisible).toBe(true);

    act(() => {
      result.current.closeDialog();
    });

    expect(result.current.state.isVisible).toBe(false);
    expect(result.current.state.activeDialog).toBeNull();
  });

  it('should throw error when used outside provider', () => {
    expect(() => {
      renderHook(() => useDialog());
    }).toThrow('useDialog must be used within a DialogProvider');
  });
});
